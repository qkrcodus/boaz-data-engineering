#### 출처 : 우아한 테크 [10분 테코톡] , 데이터중심어플리케이션설계 - 마틴 클레프만
를 토대로 이해한 내용을 정리했습니다.

- 데이터 파티셔닝이란?
큰 데이터 셋을 작은 관리 가능한 조각으로 나누는 기법 ( 논리적 테이블 -> 물리적 테이블로 )
![](https://i.imgur.com/t2DQ1jq.png)
- 목적은?
비공유 클러스터에서 다른 파티션은 다른 노드에 저장될 수 있으므로, 대용량 데이터 셋이 여러 디스크에 분산될 수 있고 여러 프로세서에 질의가 분산 될 수 있다.

ex ) mysql 은 파일 시스템으로 데이터를 관리하는데 , index 타입이 너무 많을 때 메모리에 올리기 힘들다. 파티셔닝을 통해 여러 테이블로 나누면 효율적이다.
예를 들어, log 파일은 라이프 사이클도 짧아 범위를 기준으로 파티셔닝한다.
#### mySQL 파티셔닝 하는 방법
- where 절에서 파티션을 결정할 수 있는가?
- where 절에서 인덱스를 결정할 수 있는가?

![](https://i.imgur.com/oMDtET1.png)
두번째 쿼리는 where 절이 없다. 
세번째 쿼리는 index range scan 이 안되기에 굉장히 느리다
네번째 쿼리는 모든 테이블을 둘러봐야 한다.

#### mySQL 파티션 종류
1. 레인지 파티션 - 정렬성 데이터
![](https://i.imgur.com/koM2r0B.png)

2. 리스트 파티션 - 키워드성 데이터
![](https://i.imgur.com/kT1R17b.png)

3. 해시 파티션 - 모든 데이터들이 동일한 사용 빈도 
![](https://i.imgur.com/MITs0ws.png)

4. 키 파티션 - 해시 파티션은 mod 연산으로 정수 값이 나와야하는데 안 나오는 경우 이 방법 사용
![](https://i.imgur.com/d0mMx3q.png)

if 데이터 셋이 너무 크거나 질의 처리량 높을 땐 샤딩

----
[ 목차 ]
- 파티셔닝 하는 방법 
- 데이터 색인과 파티셔닝의 상호 작용
- 클러스터에 노드를 추가하거나 삭제시 필요한 재균형화
- 데이터베이스와 파티션의 상호작용

### 파티셔닝 하는 방법 
보통 복제랑 같이 이루어져서 각 파티션의 복사본을 여러 노드에 저장한다
![](https://i.imgur.com/1Qyn4CK.png)

### 데이터 색인 방법 1( 키 범위 )
- 핫스팟 : 불균형하게 부하가 높은 파티션 ( 파티셔닝의 목적인 부하 분산에 부합하지 않은 경우 ) 을 방지 하기 위해 데이터를 무작위로 노드에 분배할 수 있겠지만, 이는 데이터를 찾으려 할 때 모든 노드를 뒤져야하는 단덪점이 있다

- 키 범위 기준 파티셔닝

![](https://i.imgur.com/Ogbfjv4.png)
키의 범위는 동일할 필요 없고, 빠르게 접근 할 수 있다는 이점이 있다.
파티션 경계는 관리자가 수동으로 선택하거나 DB에서 자동으로 선택되게 할 수 있다.

[ 단점 ]
하지만, 특정한 접근 패턴은 핫스팟을 유발할 수 있다.

ex ) 키의 첫번째 요소로 타임스탬프를 사용한다면, 날마다 한 파티션에 데이터 부하가 걸린다. => 고르게 분산되게 다른 요소를 키 값으로 정하자

### 데이터 색인 방법 2( 키 해시값 )
키 범위 기반 분산의 단점을 극복하기 위해 키에 적합한 해시 함수를 구하고, 각 파티션에 해시값 범위를 할당하자

![](https://i.imgur.com/PAn35nf.png)

이러한 일관성 해싱은 ( 파티션 크기 동일하고, 무작위 가깝게 선택 가능 ) cdn 에서 부하를 균딩하게 분산시키는 방식이다.

[ 단점 ]
- 범위 질의가 어려워진다.
- 인접한 키들이 모든 파티션에 흩어져 정렬 순서가 유지되지 않는다.

### 여전히 문제가 되는 
클라이언트가 항상 동일한 키를 읽고 쓰는 경우에는 하나의 파티션으로 모든 요청이 쏠리게 된다.

ex ) 인플루언서의 게시글에 댓글을 다는 수많은 클라이언트들 
![](https://i.imgur.com/Y6fQc7B.png)

[ 해결 방법 ]

데이터 시스템에선 최선을 다했으니 어플리케이션에서 이 현상을 해결해야한다.
각 키의 시작이나 끝에 임의의 숫자를 붙여 부하를 분산한다 vs 키를 쪼개면 읽을 때 추가 작업 필요하다 
간의 트레이드오프가 생기에 적절히 잘 선택해야한다.

---
### 파티셔닝과 보조 색인
1. 문서 기반 파티셔닝 2. 용어 기반 파티셔닝 

- 문서 기반 파티 셔닝
![](https://i.imgur.com/sbhuSw5.png)
각 항목에는 document ID라 부르는 고유 ID가 있고 이 값을 기준으로 파티션 되어 있다. ( 191, 214, 306, 515, 768, 893 - 500 기준 )
사용자가 색이랑 제조사 기준으로 필터링하고 싶다면? color 랑 make 에 보조 색인을 만들어야 한다.
다른 파티션이 어떤 데이터를 가지고 있는지에 대해 알지 못하기에 지역 색인이라고 한다. 
따라서 빨간색 자동차는 파티션 0, 파티션 1 둘 다 존재하므로 모든 파티션에 질의를 보낸다 ( scatter/gather 방법 )

- 용어 기반 파티셔닝
![](https://i.imgur.com/eSxoWa8.png)
보조색인이 자기 파티션뿐 아니라 모든 파티션의 데이터를 담당하도록 만든다면 이는 전역색인이라고 한다.
하지만, 보조색인도 파티션해야하므로 color 들을 알파벳순으로 정렬후  a-r : 파티션 0 s-z : 파티션 1에 지정했다.

[ 단점 ]
읽기는 효율적이나 전역 쓰기는 느리고 복잡하다. 

ex ) '노드 A'에 새로운 고객 정보가 저장되면, 이 데이터에 해당하는 전화번호는 전역 색인에 추가되어야 하고, 전역 색인은 모든 노드에 걸쳐 있으므로, 이 색인의 일관성을 유지하기 위해 '노드 B', '노드 C' 등에도 해당 색인 정보의 업데이트가 필요

---
### 파티셔닝 재균형화
데이터베이스에는 변화가 생기면 클러스터의 한 노드에서 발생한 부하를 다른 노드로 옮겨야한다 ( 재균형화 )

- 해시 방법으로 모듈러 연산 - 쓰면 x
노드가 계속해서 변경되는 경우
노드가 11대: 123456 mod 11 = 3
노드가 12대: 123456 mod 12 = 0 로 재균형화 비용이 커진다

- 파티션 개수 고정
파티션 개수를 노드 개수보다 많이 만들고 새로운 노드가 추가되면 할당한다. 
![](https://i.imgur.com/mhOStUb.png)

- 동적 파티셔닝
데이터베이스의 파티션 크기가 미리 정해진 임계값을 초과하면 자동으로 파티션을 분할하여 데이터를 균등하게 분산시킨다.
반대로, 파티션의 데이터가 너무 적어져서 임계값 이하로 떨어지면, 인접한 파티션과 합쳐질 수도 있다.

- 노드 비례 파티셔닝
데이터베이스의 각 노드가 고정된 수의 파티션을 가지고 운영되고 새로운 노드가 추가되면 기존 노드들로부터 무작위로 파티션을 선택하여 새 노드에 재할당하며, 이 과정에서 선택된 파티션은 기존 노드와 새 노드 사이에서 데이터를 분할한다.
---
### 요청 라우팅
![](https://i.imgur.com/lWbi1tv.png)
클라이언트에서 요청 보내려고 할 땐 어느 노드로 접속해야하는지 어떻게 알까?

파티션이 어느 노드에 할당 되었는지 누가 알고 있느냐 따라 3가지 방법이 있다.

![](https://i.imgur.com/RQTal9y.png)


올바를 정보를 모든 곳이 알고 있어야 하기에 주키퍼 같은 서비스를 사용한다. 
![](https://i.imgur.com/5Vq5Qnf.png)
