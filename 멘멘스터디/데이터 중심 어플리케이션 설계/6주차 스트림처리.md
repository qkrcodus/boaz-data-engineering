### 스트림과 테이블
- 연속적으로 흘러가는 데이터의 흐름  -> stream 
- 데이터를 구조화된 형식(행과 열)으로 저장하는 방식 -> table 
##### [ stream 활용 예시 ]
배달의 민족에선 배달 주문의 진행 상황을 실시간으로 추적하기 위해 이벤트 스트림을 활용한다. 주문 생성, 배차 완료, 픽업 완료, 배달 완료 등의 이벤트가 시간 순서대로 스트림으로 처리되며, 이를 통해 주문의 현재 상태를 실시간으로 갱신하고 관련 행동을 취할 수 있다.
##### [ table 활용 예시 ]
각 주문의 상태를 저장하는 테이블은 주문 ID, 고객 ID, 라이더 ID, 주문 상태, 주문 시간 등의 정보를 포함할 수 있다. 스트림을 통해 이벤트가 처리될 때마다 이 테이블은 최신 상태로 갱신된다.

---
### 스트림 조인
- 스트림 : 연속적으로 흐르는 데이터나 이벤트, 끝이 없다.
스트림 상에서 새로운 이벤트가 언제든 나타날 수 있기에 동적으로 생성되는 데이터나 이벤트는 스트림을 조인하는 것을 훨씬 더 어렵게 만든다.

---
### 스트림 조인 유형3가지
1. stream stream join
2. stream table join
3. table table join
---
### 1. stream stream join
데이터 스트림들 사이에서 일어나는 결합을 의미한다.
##### [ 예시 ] 검색 결과에서 각 url 당 클릭율 구하기
사용자가 웹사이트에 키워드 검색 -> 검색 이벤트
검색으로 나타난 url 중 하나를 클릭 -> 클릭 이벤트

사용자가 "카프카"이라는 키워드로 검색을 하고 그 결과로 나타난 여러 url 중 하나를 클릭하는 경우 두 이벤트는 같은 세션 ID를 통해 연결된다.

1. "카프카"을 검색할 때 검색 이벤트 상태 저장소에 세션 ID 와 검색된 url 목록을 저장한다.
2. url 을 클릭할 때 클릭 이벤트 상태 저장소에서 세션 ID 와 클릭한 url을 저장한다.
3. 클릭 이벤트 발생 시, 시스템이 세션 ID를 기반으로 해당 사용자의 검색 이벤트 정보를 찾아보며 클릭된 url이 검색 결과에 포함되어 있는지 확인한다.
4. 클릭 이벤트와 매칭되는 검색 이벤트가 있다면 "검색 결과 클릭 확인 이벤트"를 발행하고
   매칭되는 검색 이벤트가 없다면 "검색 결과 클릭되지 않았음 이벤트"를 발행한다.

이처럼 스트림 처리자는 상태 저장소를 이용하여 상태를 유지해야한다.

---
### 2. stream table join
실시간 데이터 스트림(이벤트 스트림)과 정적 또는 덜 변동적인 데이터(테이블)사이에 일어나는 결합을 의미한다.
##### [ 예시 ] 쇼핑몰에서 사용자의 상품 조회할 때
각 조회 이벤트는 상품 ID가 포함 될 것이다. 
- **이벤트 스트림**: `{userId: "user123", productId: "prod456", timestamp: "2021-01-01T12:00:00"}`
- **상품 정보 테이블**: `{productId: "prod456", price: 20000, description: "고성능 노트북", stock: 10}`

이 경우, 스트림-테이블 조인을 통해 각 상품 조회 이벤트에 상품의 가격, 설명, 재고 수량 등의 정보를 추가할 수 있다.
즉 stream table join은 데이터베이스 정보로 활동 이벤트를 강화한다.

cf ) 데이터베이스로의 원격 질의는 네트워크 지연과 데이터베이스 부하를 유발할 수 있기에 데이터베이스의 로컬 복사본을 스트림 처리자 내부에 둘 수 있다. 

---
### 3. table table join
두 개 이상의 테이블 사이에 일어나는 결합을 의미한다.
##### [ 예시 ] 트위터의 타임라인 - 사용자별 타임라인 캐시 사용
- 사용자 b 가 트윗을 보내면 b의 팔로워들의 타임라인에 트윗이 추가된다.
- b 가 트윗을 삭제하면 b의 팔로워들의 타임라인에 트윗이 삭제된다.
- b 가 o 를 팔로우하기 시작하면, o 의 최근 트윗을 b 타임라인에 추가한다.
- b 가 o 를 언팔하면, o 의 최근 트윗을 b 타임라인에서 삭제한다.

스트림 처리자가 이를 구현하기 위해선 트위트 이벤트 스트림과 팔로우 관계 이벤트 스트림들은 특정 시점에서 트윗과 팔로우 집합이 포합된 데이터베이스를 유지해야한다.

이를 위해 팔로워 테이블과 트위터 테이블을 결합한다.

`SELECT follows.follower_id AS timeline_id,`
       `array_agg(tweets.* ORDER BY tweets.timestamp DESC)`
`FROM tweets`
`JOIN follows ON follows.followee_id = tweets.sender_id`
`GROUP BY follows.follower_id`

![](https://i.imgur.com/jQE3Usv.png)

![](https://i.imgur.com/v6ODksv.png)

![](https://i.imgur.com/tsHX9Z0.png)

tweets 의 sender_id가 follows.followee_id가 같은 경우 해당 tweets 와 follows 테이블을 조인하고 결과를 followee_id 별로 그룹화한다.

sql의 질의 결과의 캐시가 타임라인이 되고 조인 대상 테이블이 변경될때마다 갱신된다.

---
### 시간 의존성
세가지 조인 방법 모두 이벤트의 순서가 중요하다. 단일 파티션 내 이벤트 순서는 보장되지만, 다른 파티션이나 다른 스트림 사이 순서를 보장하기 위한 일반적인 방법은 없다고 한다. 

-> kafka는 애초에 순서 보장이 필요한 이벤트들은 같은 토픽을 부여해 하나의 파티션으로 보낸다.

-> 수시로 변경되는 세율 -> 바뀔때마다 새 식별자 부여해 -> 판매 시점에 세율을 표시하는 식별자를 송장에 포함한다. -> 레코드의 모든 버전 보유 필수 : 로그 컴팩션 불가

cf) 로그 컴팩션 : 주기적으로 같은 키의 로그 레코드를 찾아 중복을 제거하고 각 키에 대해 가장 최근에 갱신된 내용만 유지해줌

---
### Apache Kafka Streams 이란?
메시지 브로커 Apache Kafka에서 제공하는 스트림 처리 라이브러리다.
### Apache Kafka Streams 의 kstream ktable
![](https://i.imgur.com/NyCpX5L.png)
- #### KTable
메시지 키 기준으로 묶이므로, 가장 최신 레코드를 사용, 토픽 내 특정 파티션을 대상으로

- #### KStream 
토픽의 모든 레코드를 조회가능

- #### Global KTable
KTable과 같이 메시지 키를 기준으로 데이터를 저장하지만, 토픽 내 전체 파티션을 대상으로

### Kafka Streams에서 지원하는 세 가지 유형의 조인
![](https://i.imgur.com/bQpYE49.png)
### 내부 조인 (Inner Joins)
내부 조인은 두 입력 소스(스트림 또는 테이블)가 같은 키를 가진 레코드를 가질 때 출력을 생성한다. 모든 조합이 가능하며, 각 조합에 대해 일치하는 키가 있는 레코드가 출력된다.

예) 사용자 정보 스트림 + 주문 정보 스트림
두 스트림 모두에 존재하는 사용자의 주문 정보만을 추출한다.
### 왼쪽 조인 (Left Joins)
왼쪽 조인은 주 입력 소스(왼쪽 소스)의 각 레코드에 대해 출력을 생성한다. 만약 다른 소스에 일치하는 키가 없다면, 해당 키의 값으로 null이 설정된다.

예) 사용자 정보 스트림 + 주문 정보 스트림
모든 사용자 정보는 나타나지만, 일부 사용자는 주문 정보가 없을 수 있다. 이 경우, 주문 정보는 null로 표시된다.

### 외부 조인 (Outer Joins)
외부 조인은 두 입력 소스 중 하나라도 키가 있는 경우, 해당 레코드에 대한 출력을 생성합니다. 만약 한 소스에만 키가 있으면 다른 소스의 해당 키 값은 null로 설정된다.

예 ) 사용자 정보 + 주문 정보
사용자 정보만 있거나 주문 정보만 있는 경우도 결과에 포함되어, 어떤 사용자는 주문 정보 없이, 어떤 주문은 사용자 정보 없이 표시된다.

