#### 복제란?
한 서버에서 다른 서버로 데이터가 옮겨 가는 것
원본 : source 복제 : replica server

#### 목적?
1. 쿼리 분산을 위해 DB를 증설하는 것
2. 소스 서버 장애 났을 경우 데이터 백업을 위해
3. 데이터 분석용 쿼리를 날리는 작업을 위한 분석용 쿼리 전용 환경 구축
4. cdn 개념처럼 ( 어플리케이션과 db서버의 물리적 거리를 극복하게 해주는 ) 데이터의 지리석 분산을 위해

#### 복제에서 사용되는 도구 (mySql 복제)
1. 바이러니 로그 : 소스 서버에 존재하는 로그 파일 ( 소스 서버의 모든 데이터 변경 내역들을 볼 수 있다. )
2. 릴레이 로그 : 레플리카 서버에 존재하는 로그 파일 ( 소스 서버의 바이너리 로그를 전해 받는다. )

#### 복제에 사용되는 스레드
1. 소스 서버에 존재하는 : 바이너리 로그 덤프 스레드 
   ( 아직 반영되지 않은 바이러니 로그들을 레플리카 서버로 전달한다. )
2. 레플리카 서버에 존재하는 : 레플리케이션 I/O 스레드
   ( 바이너리 로그 덤프 스레드로부터 받아온 이벤트 내역을 릴레이 로그에 저장 )
3. 레플리카 서버에 존재하는 : 레플리케이션 sql 스레드
   ( 릴레이 로그 파일의 이벤트를 실행시켜 실제 데이터 파일에 적용 )

#### DB replica 구성 방식은 대표적으로 single , multi replica 구조가 있다

![](https://i.imgur.com/TnJ1mNG.png)

![](https://i.imgur.com/IOleArS.png)

#### 복제가 이루어지는 과정 

![](https://i.imgur.com/zBTA47M.png)

소스 서버에 변경이 발생하면
트랜잭션 처리 스레드가 이를 바이너리 로그에 기록한다
레플리카 서버가 바이너리 로그 요청을 하면
바이너리 로그 덤프 스레드는 바이너리 로그로부터 변경 사항을 조회하고 이를 레플리케이션 i/o 스레드로 전송한다
전달 받은 바이너리 로그를 릴레이 로그에 적는다
릴레이 로그를 계속해서 모니터링하면서 새로운 이벤트가 발견될 때마다 즉시 실행되느 레플리케이션 sql 스레드는 데이터 파일에 변경사항을 반영하면 복제 과정이 끝이 난다

#### 복제 동기화 방식
- 비동기 복제 : 복제 이벤트만 전달할뿐 응답을 화인하지 않음
![](https://i.imgur.com/WXs7s7X.png)
즉, 소스서버는 레플리카 서버로부터 복제 완료되었다는 응답 없이 storage engine에 커밋한다

- 반동기 복제 : 복제 이벤트 전달후 릴레이 로그에 쓰여지는 것을 확인 후 storage engine에 커밋한다
릴레이 로그에 쓰여지는 건 복제를 ' 완료 '하는 것은 아니기에 "반"동기 복제라고 한다

![](https://i.imgur.com/T3ggDET.png)

ack 를 받아야 커밋한다.

---
### 노드 간 변경을 복제하기 위한 3가지 알고리즘 중 리더 기반 복제

[ 모든 write 은 모든 복제 서버에서 처리되어야 하기에 일반적으로 리더 기반 복제 방식을 이용한다 ]
데이터베이스의 복사본을 저장하는 각 노드를 복제 서버라고 한다. 
![](https://i.imgur.com/YTYnwUA.png)
클라이언트 1234가 리더 복제 서버에게 write요청을 보내고. 리더 복제 서버는 로컬 db에 이를 정한 뒤, 복제 로그나 변경 스트림의 일부에 데이터 변경을 담아 팔로워 복제 서버에게 전송한다.

리더 기반 복제는 관계형, 비관계형 데이터 베이스에서 사용된다.
[ 즉, 클라이언트의 write 요청을 리더 복제서버에게, read 요청을 모든 복제 서버에게 보낼 수 있다.]

#### 비동기 vs 반동기 복제

- 비동기 복제 방식 : 레플리카로 이벤트가 잘 전달 되었는지, 실제로 이벤트 복제가 잘 이루어졌는지 알 수 없고, 보장하지도 않는다. 하지만 트랜잭션 처리는 아주 빨라진다.

- 반동기 복제 방식 : 소스 서버의 이벤트가 레플리카 서버에 잘 전달된 것을 확인한 뒤에서야, 소스 서버의 트랜잭션을 마무리하는 방식이다. 조금 느리지만 레플리카 서버로의 전송을 보장해준다.



---
### 복제 지연 문제

복제 지연으로 인해 발생할 수 있는 몇 가지 이상 현상을 설명하고 있다.
#### 복제란?
한 서버에서 다른 서버로 데이터를 동기화하는 것 
원본 : source server , 복제 : replica server
#### 목적?
1. DB를 증설하여 쿼리 분산을 위해
2. 소스 서버 장애 났을 경우 데이터 백업을 위해
3. 데이터 분석용 쿼리를 날리는 작업을 위한 분석용 쿼리 전용 환경 구축
4. cdn 개념처럼 ( 어플리케이션 서버와 db서버의 물리적 거리를 극복하게 해주는 ) 데이터의 지리석 분산을 위해

=> 종합적으로 시스템이 장애에도 불구하고 지속적으로 서비스를 제공할 수 있는 능력인 고가용성을 위해서 복제 작업을 한다. 

#### 복제가 이루어지는 과정 

![](https://i.imgur.com/zBTA47M.png)

1. 소스 서버에 변경이 발생하면 트랜잭션 처리 스레드가 이를 바이너리 로그에 기록한다
2. 레플리카 서버가 바이너리 로그 요청을 하면 바이너리 로그 덤프 스레드는 바이너리 로그로부터 변경 사항을 조회하고 이를 레플리케이션 i/o 스레드로 전송한다
3. 전달 받은 바이너리 로그를 릴레이 로그에 적는다
4. 릴레이 로그를 계속해서 모니터링하면서 새로운 이벤트가 발견될 때마다 즉시 실행되느 레플리케이션 sql 스레드는 데이터 파일에 변경사항을 반영하면 복제 과정이 끝이 난다

#### 복제 동기화 방식
- 비동기 복제 : 복제 이벤트만 전달할뿐 응답을 화인하지 않음
![](https://i.imgur.com/WXs7s7X.png)
즉, 소스서버는 레플리카 서버로부터 복제 완료되었다는 응답 없이 storage engine에 커밋한다

- 반동기 복제 : 복제 이벤트 전달후 릴레이 로그에 쓰여지는 것을 확인 후 storage engine에 커밋한다
릴레이 로그에 쓰여지는 건 복제를 ' 완료 '하는 것은 아니기에 "반"동기 복제라고 한다

![](https://i.imgur.com/T3ggDET.png)

ack 를 받아야 커밋한다.

cf ) 동기 복제를 사용하게 된다면, 모든 노드의 응답을 기다려야하므로 네트워크 지연이나, replica 노드가 다운 되었을때 성능이 심하게 저하된다 단, 레플리카 간 데이터 불일치의 위험을 줄일 순 있다. 
#### 복제 지연 문제 - 주로 비동기 방식의 복제 과정에서 발생
Replication Lag : source server 로부터 replica server 까지 복제되는데 걸리는 시간 
#### 1.  read after write 일관성 채택


![](https://i.imgur.com/vrFnQcr.png)
[ 문제 상황 ]
클라이언트가 소스 서버에 데이터를 쓴다
클라이언트가 레플리카 서버에 데이터를 읽으려 하지만, 복제가 완료 되지 않았다면 결과 없음 응답을 반환 할 것이다. 

[ 즉, read after write 일관성이 필요하다. ]
사용자가 페이지를 재로딩 했을 때, 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장

[ read-after-write consistency는 어떻게 확보할까? ]
- 사용자가 수정한 내용은 리더 source db 에서 읽는다. 
- 마지막 갱신 시각을 찾고, 갱신 시각 후 일정 시간동안 source db에서 읽는다
- 클라이언트의 가장 최근 쓰기 트랜잭션까지 갱신된 복제 서버에서만 읽거나, 해당 타임스탬프까지 복제 전에는 질의 대기한다.
![](https://i.imgur.com/ejIhuDr.png)


#### 2. 단조 읽기

![](https://i.imgur.com/WSUrC7o.png)
[ 문제 상황 ]
사용자가 연속적으로 읽기 작업 시도를 한다
지연 속도가 다른 두개의 팔로워 노드로 인해 팔로워 1은 제대로 응답을 하지만, 팔로워 2는 결과 없음을 반환한다
즉, 이전에 읽혔던 내용이 다음 요청에서 안 읽히는 문제가 생길 수도 있다.

[ 일관성이 떨어지는 문제는 어떻게 해결할까? ]
- 사용자 읽기가 항상 동일한 복제 서버에서 수행되게 하는 단조 읽기 방법 
- 다만, 복제 서버 장애시 그 모든 요청을 다른 복제 서버로 라우팅 해줘야 한다. 
- 사용자 ID의 해시를 기반으로 복제 서버를 선택
![](https://i.imgur.com/ApQwXVs.png)


#### 3. 일관된 순서로 읽기
데이터 베이스 다중화를 위해 데이터베이스를 샤딩했다. 각 샤드는 독립적으로 동작하기에
복제 지연 시간이 다른 각 파티션은 인과 관계가 잘못된 현상을 관찰자가 볼 수 있다.

![](https://i.imgur.com/LUaq2tu.png)
[ 문제 상황 ]
샤딩된 데이터 베이스 1, 2 가 있다
관찰자 입장에서 복제 지연이 느린 파티션 1 팔로워 서버보다 파티션 2 팔로워 서버의 데이터를 먼저 읽게 된다. 

[ 인과성이 떨어지는 현상은 어떻게 해결할까? ]
- 일관된 순서로 읽기와 같은 유형의 보장이 필요 (Consistent Prefix Read)

< 소스와 레플리카 서버 사이의 복제 지연 해결 방법 >

---
< 전환 중인 서버 사이의 복제 지연 해결 방법 >
#### cf - 네이버페이 결제 서비스 사례
원래 단일 노드 트랙잭션, 죽 한개의 데이터베이스 서버에서만 데이터 처리가 이루어졌었는데 증가하는 주문/결제 트래픽에 분산 db의 필요성을 느꼈다.

만약 read 위주의 서비스였다면, replica 증설하여 read only 요청을 분산할 수 있겠다.
![](https://i.imgur.com/BTPJjjN.png)
하지만, 네이퍼 페이는 나만의 데이터로 주문하고 주문에 대한 상태가 계속적으로 변하기에 write에 대한 요구 사항이 있었기에 샤딩을 할 수밖에 없었다.

![](https://i.imgur.com/wnqrtyB.png)

##### - 과연 무엇으로 샤드 키를 설정 할 것인가? 
주문엔 주문자, 판매자, 주문 내역이 담긴다
user key로 샤드를 한다면, 사용자별로 데이터를 분리하여 저장 가능하겠지만, 판매자가 모든 주문 정보를 조회하여야 할 때, 문제가 생길 수 있다.

따라서 구매자 db, 판매자 db 를 각각 구축했다.
##### - db 전환시의 복제 지연
전환을 점진적으로 진행하며, 문제가 발생하면 트랜잭션 단위로 롤백을 수행한다. 
단일 db <-> 샤딩된 db 의 복제가 필요한데, 복제 지연 문제가 생긴다
단일 데이터베이스 시스템에서 분산 데이터베이스 시스템으로의 전환 과정에선 책에서 다룬 일반적인 방법들 말고 
dual write driver 적용하여 애플리케이션 차원에서 단일 db 와 구매자 db에 동시에 쓸 수 있게 했다. 
-> 애플리케이션에 부담을 줄 수 있는 좋지 않은 방식
![](https://i.imgur.com/4hlZJWg.png)

[ 결론, 복제 지연을 해결하는 방법은 시스템 구성과 요구 사항에 따라 달라질 수 있다. 책에 언급된 방법들만 존재하는게 아니다. ]
#### 복제 시스템에서 장애가 난 경우 해결책
복제를 하다가 레플리카 서버에 문제가 생겼다면? 어디서부터 복제를 진행해여 동기화를 할까?
![](https://i.imgur.com/8oBxfvf.png)

그 전에 
#### 복제에서 사용되는 도구 ( mySql )
1. 바이러니 로그 : 소스 서버에 존재하는 로그 파일 ( 소스 서버의 모든 데이터 변경 내역들을 볼 수 있다. )
2. 릴레이 로그 : 레플리카 서버에 존재하는 로그 파일 ( 소스 서버의 바이너리 로그를 전해 받는다. )
#### 복제에 사용되는 스레드
1. 소스 서버에 존재하는 : 바이너리 로그 덤프 스레드 
   ( 아직 반영되지 않은 바이러니 로그들을 레플리카 서버로 전달한다. )
2. 레플리카 서버에 존재하는 : 레플리케이션 I/O 스레드
   ( 바이너리 로그 덤프 스레드로부터 받아온 이벤트 내역을 릴레이 로그에 저장 )
3. 레플리카 서버에 존재하는 : 레플리케이션 sql 스레드
   ( 릴레이 로그 파일의 이벤트를 실행시켜 실제 데이터베이스에 적용 )

![](https://i.imgur.com/sp92SfT.png)

mySQL 은 크레시 세이브 복제 방식을 제공하여 고가용성을 보장한다.
#### 작동 방식
- 복제 서버가 예기치 않은 충돌로 인해 다운된다
- 서버가 다시 시작되면 레플리케이션 I/O 스레드와 SQL 스레드가 자동으로 재시작된다.
- 복제 서버는 바이너리 로그의 마지막 읽기 위치와 SQL 이벤트의 마지막 실행 위치를 로컬에 저장하는데, 이 지점을 읽어 소스서버의 바이러니 로그에서 중단된 위치 부터 다시 이벤트를 읽어 나간다.

---
### 노드 간 변경을 복제하기 위한 3가지 알고리즘 중 다중 리더 복제

#### 다중 데이터 센터 운영
![](https://i.imgur.com/00uCuyd.png)

[ 문제 상황 ]
가장 큰 문제는 쓰기 충돌이 발생한다는 점이다. 
![](https://i.imgur.com/uvoRrNZ.png)
[ 해결 방법 ]
1. 동기적으로 충돌을 감지하고, 다른 서버들에게 응답 받을 때 까지 기다리는 방법은 복제 서버가 독립적으로 쓰기 할 수 있다는 이점이 무용지물이 되어 버린다
2. 쓰기에 타임스탬프를 부여해 나중에 수정된 쓰기로 덮어쓴다
3. 충돌 회피 - - 하나의 레코드 내에서 일어나는 모든 쓰기 액션을 같은 리더 안에서 진행하도록 하는 것

[ 리더가 여러개일 경우 토폴로지 ]
한 노드에서 다른 노드로 쓰기를 전달하는 통신 경로

- circular topology (원형, mysql 의 진행방식), 별모양 토폴로지
모든 노드를 순차적으로 거치기 때문에 무한루프 방지용 로그 트래킹이 필요하다.
하나의 노드에 장애가 발생하면 다른 노드 간 복제 메시지 흐름에 방해를 준다.

- all-to-all 전체연결, (그물망 토폴로지)
네트워크 연결 속도에 따라 일부 복제 메시지가 다른 메시지를 추월할 수 있다.

---

