#### 복제란?
한 서버에서 다른 서버로 데이터가 옮겨 가는 것
원본 : source 복제 : replica server

#### 목적?
1. 쿼리 분산을 위해 DB를 증설하는 것
2. 소스 서버 장애 났을 경우 데이터 백업을 위해
3. 데이터 분석용 쿼리를 날리는 작업을 위한 분석용 쿼리 전용 환경 구축
4. cdn 개념처럼 ( 어플리케이션과 db서버의 물리적 거리를 극복하게 해주는 ) 데이터의 지리석 분산을 위해

#### 복제에서 사용되는 도구 (mySql 복제)
1. 바이러니 로그 : 소스 서버에 존재하는 로그 파일 ( 소스 서버의 모든 데이터 변경 내역들을 볼 수 있다. )
2. 릴레이 로그 : 레플리카 서버에 존재하는 로그 파일 ( 소스 서버의 바이너리 로그를 전해 받는다. )

#### 복제에 사용되는 스레드
1. 소스 서버에 존재하는 : 바이너리 로그 덤프 스레드 
   ( 아직 반영되지 않은 바이러니 로그들을 레플리카 서버로 전달한다. )
2. 레플리카 서버에 존재하는 : 레플리케이션 I/O 스레드
   ( 바이너리 로그 덤프 스레드로부터 받아온 이벤트 내역을 릴레이 로그에 저장 )
3. 레플리카 서버에 존재하는 : 레플리케이션 sql 스레드
   ( 릴레이 로그 파일의 이벤트를 실행시켜 실제 데이터 파일에 적용 )
   
---
### 노드 간 변경을 복제하기 위한 3가지 알고리즘 중 리더 기반 복제

[ 모든 write 은 모든 복제 서버에서 처리되어야 하기에 일반적으로 리더 기반 복제 방식을 이용한다 ]
데이터베이스의 복사본을 저장하는 각 노드를 복제 서버라고 한다. 
![](https://i.imgur.com/YTYnwUA.png)
클라이언트 1234가 리더 복제 서버에게 write요청을 보내고. 리더 복제 서버는 로컬 db에 이를 정한 뒤, 복제 로그나 변경 스트림의 일부에 데이터 변경을 담아 팔로워 복제 서버에게 전송한다.

리더 기반 복제는 관계형, 비관계형 데이터 베이스에서 사용된다.
[ 즉, 클라이언트의 write 요청을 리더 복제서버에게, read 요청을 모든 복제 서버에게 보낼 수 있다.]

#### 비동기 vs 반동기 복제

- 비동기 복제 방식 : 레플리카로 이벤트가 잘 전달 되었는지, 실제로 이벤트 복제가 잘 이루어졌는지 알 수 없고, 보장하지도 않는다. 하지만 트랜잭션 처리는 아주 빨라진다.

- 반동기 복제 방식 : 소스 서버의 이벤트가 레플리카 서버에 잘 전달된 것을 확인한 뒤에서야, 소스 서버의 트랜잭션을 마무리하는 방식이다. 조금 느리지만 레플리카 서버로의 전송을 보장해준다.

---
### 복제 지연 문제

복제 지연으로 인해 발생할 수 있는 몇 가지 이상 현상을 설명하고 있다.
#### 복제란?
한 서버에서 다른 서버로 데이터를 동기화하는 것 
원본 : source server , 복제 : replica server
#### 목적?
1. DB를 증설하여 쿼리 분산을 위해
2. 소스 서버 장애 났을 경우 데이터 백업을 위해
3. 데이터 분석용 쿼리를 날리는 작업을 위한 분석용 쿼리 전용 환경 구축
4. cdn 개념처럼 ( 어플리케이션 서버와 db서버의 물리적 거리를 극복하게 해주는 ) 데이터의 지리석 분산을 위해

=> 종합적으로 시스템이 장애에도 불구하고 지속적으로 서비스를 제공할 수 있는 능력인 고가용성을 위해서 복제 작업을 한다. 
#### 복제 지연 문제
Replication Lag : source server 로부터 replica server 까지 복제되는데 걸리는 시간 
#### 1.  read after write 일관성 채택


![](https://i.imgur.com/vrFnQcr.png)
[ 문제 상황 ]
클라이언트가 소스 서버에 데이터를 쓴다
클라이언트가 레플리카 서버에 데이터를 읽으려 하지만, 복제가 완료 되지 않았다면 결과 없음 응답을 반환 할 것이다. 

[ 즉, read after write 일관성이 필요하다. ]
사용자가 페이지를 재로딩 했을 때, 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장

[ read-after-write consistency는 어떻게 확보할까? ]
- 사용자가 수정한 내용은 리더 source db 에서 읽는다. 
- 마지막 갱신 시각을 찾고, 갱신 시각 후 일정 시간동안 source db에서 읽는다
- 클라이언트의 가장 최근 쓰기 트랜잭션까지 갱신된 복제 서버에서만 읽거나, 해당 타임스탬프까지 복제 전에는 질의 대기한다.
![](https://i.imgur.com/ejIhuDr.png)


#### 2. 단조 읽기

![](https://i.imgur.com/WSUrC7o.png)
[ 문제 상황 ]
사용자가 연속적으로 읽기 작업 시도를 한다
지연 속도가 다른 두개의 팔로워 노드로 인해 팔로워 1은 제대로 응답을 하지만, 팔로워 2는 결과 없음을 반환한다
즉, 이전에 읽혔던 내용이 다음 요청에서 안 읽히는 문제가 생길 수도 있다.

[ 일관성이 떨어지는 문제는 어떻게 해결할까? ]
- 사용자 읽기가 항상 동일한 복제 서버에서 수행되게 하는 단조 읽기 방법 
- 다만, 복제 서버 장애시 그 모든 요청을 다른 복제 서버로 라우팅 해줘야 한다. 
- 사용자 ID의 해시를 기반으로 복제 서버를 선택
![](https://i.imgur.com/ApQwXVs.png)


#### 3. 일관된 순서로 읽기
데이터 베이스 다중화를 위해 데이터베이스를 샤딩했다. 각 샤드는 독립적으로 동작하기에
복제 지연 시간이 다른 각 파티션은 인과 관계가 잘못된 현상을 관찰자가 볼 수 있다.

![](https://i.imgur.com/LUaq2tu.png)
[ 문제 상황 ]
샤딩된 데이터 베이스 1, 2 가 있다
관찰자 입장에서 복제 지연이 느린 파티션 1 팔로워 서버보다 파티션 2 팔로워 서버의 데이터를 먼저 읽게 된다. 

[ 인과성이 떨어지는 현상은 어떻게 해결할까? ]
- 일관된 순서로 읽기와 같은 유형의 보장이 필요 (Consistent Prefix Read)

#### 복제 시스템에서 장애가 난 경우 해결책
복제를 하다가 레플리카 서버에 문제가 생겼다면? 어디서부터 복제를 진행해여 동기화를 할까?
![](https://i.imgur.com/8oBxfvf.png)

그 전에 
#### 복제에서 사용되는 도구 ( mySql )
1. 바이러니 로그 : 소스 서버에 존재하는 로그 파일 ( 소스 서버의 모든 데이터 변경 내역들을 볼 수 있다. )
2. 릴레이 로그 : 레플리카 서버에 존재하는 로그 파일 ( 소스 서버의 바이너리 로그를 전해 받는다. )
#### 복제에 사용되는 스레드
1. 소스 서버에 존재하는 : 바이너리 로그 덤프 스레드 
   ( 아직 반영되지 않은 바이러니 로그들을 레플리카 서버로 전달한다. )
2. 레플리카 서버에 존재하는 : 레플리케이션 I/O 스레드
   ( 바이너리 로그 덤프 스레드로부터 받아온 이벤트 내역을 릴레이 로그에 저장 )
3. 레플리카 서버에 존재하는 : 레플리케이션 sql 스레드
   ( 릴레이 로그 파일의 이벤트를 실행시켜 실제 데이터베이스에 적용 )

![](https://i.imgur.com/sp92SfT.png)

mySQL 은 크레시 세이브 복제 방식을 제공하여 고가용성을 보장한다.
#### 작동 방식
- 복제 서버가 예기치 않은 충돌로 인해 다운된다
- 서버가 다시 시작되면 레플리케이션 I/O 스레드와 SQL 스레드가 자동으로 재시작된다.
- 복제 서버는 바이너리 로그의 마지막 읽기 위치와 SQL 이벤트의 마지막 실행 위치를 로컬에 저장하는데, 이 지점을 읽어 소스서버의 바이러니 로그에서 중단된 위치 부터 다시 이벤트를 읽어 나간다.

---
### 노드 간 변경을 복제하기 위한 3가지 알고리즘 중 다중 리더 복제
쓰기를 허용하는 리더가 많아지면, 각 리더는 동시에 다른 리더의 팔로워 역할도 한다
#### 다중 데이터 센터 운영
![](https://i.imgur.com/00uCuyd.png)

---
### 노드 간 변경을 복제하기 위한 3가지 알고리즘 중 리더 없는 복제
